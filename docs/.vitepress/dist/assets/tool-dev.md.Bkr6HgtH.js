import{_ as i,c as a,a0 as t,o as n}from"./chunks/framework.CoDf8mVe.js";const l="/assets/plugin-new-project.2hR9lsis.png",e="/assets/plugin-item.jNMAxtGu.png",p="/assets/plugin-publish.CsSOERo5.png",h="/assets/plugin-folder.Cx3JotoD.png",u=JSON.parse('{"title":"插件开发","description":"","frontmatter":{},"headers":[],"relativePath":"tool-dev.md","filePath":"tool-dev.md","lastUpdated":null}'),k={name:"tool-dev.md"};function r(d,s,o,E,c,g){return n(),a("div",null,s[0]||(s[0]=[t('<h1 id="插件开发" tabindex="-1">插件开发 <a class="header-anchor" href="#插件开发" aria-label="Permalink to &quot;插件开发&quot;">​</a></h1><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>目前哔哩助理的插件仅在 C# 上进行了测试，python 和 java 没有做额外测试，不保证能工作。</p></div><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><p>哔哩助理的整体运行架构基于 <a href="https://github.com/microsoft/semantic-kernel" target="_blank" rel="noreferrer">semantic-kernel</a>。而插件部分对应的是 <a href="https://learn.microsoft.com/en-us/semantic-kernel/agents/plugins/using-the-kernelfunction-decorator?tabs=Csharp" target="_blank" rel="noreferrer">Native Functions</a>。</p><p>如果你需要为哔哩助理开发插件，那么实际上就是创建一个类库（Class Library），然后引入 semantic kernel 相关的包，按照 <a href="https://learn.microsoft.com/en-us/semantic-kernel/agents/plugins/using-the-kernelfunction-decorator?tabs=Csharp" target="_blank" rel="noreferrer">Native Functions</a> 的引导构建插件，发布 DLL，然后把程序集导入到哔哩助理中，哔哩助理就会通过反射获取你在代码内定义的函数列表，从而实现 semantic kernel 中的本地函数调用。</p><h2 id="开发环境" tabindex="-1">开发环境 <a class="header-anchor" href="#开发环境" aria-label="Permalink to &quot;开发环境&quot;">​</a></h2><table tabindex="0"><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>开发工具</td><td>Visual Studio 2022 或者 Visual Studio Code</td></tr><tr><td>SDK</td><td>.NET 8</td></tr></tbody></table><h2 id="创建项目" tabindex="-1">创建项目 <a class="header-anchor" href="#创建项目" aria-label="Permalink to &quot;创建项目&quot;">​</a></h2><p>简单起见，创建一个基于 .NET 8 的类库即可（其实可以是任意 .NET 版本，包括 .NET Standard 2.0 / .NET 6 等，但不能是 .NET Framework）。我们可以命名为 <code>RodelAgent.Samples.Plugin</code></p><p><img src="'+l+`" alt="创建新项目"></p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>本文所创建的示例代码在这里：<a href="https://github.com/Richasy/Rodel.Agent/tree/main/src/Samples/RodelAgent.Samples.Plugin" target="_blank" rel="noreferrer">Samples</a></p></div><h2 id="引入-nuget-包" tabindex="-1">引入 nuget 包 <a class="header-anchor" href="#引入-nuget-包" aria-label="Permalink to &quot;引入 nuget 包&quot;">​</a></h2><p>我们只需要使用 <code>KernelFunction</code> 等特性，所以只需要引入 <a href="https://www.nuget.org/packages/Microsoft.SemanticKernel.Abstractions/" target="_blank" rel="noreferrer">Microsoft.SemanticKernel.Abstractions</a> 即可。</p><p>引入完成后，<code>csproj</code> 文件如下：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Project</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sdk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Microsoft.NET.Sdk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">PropertyGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">TargetFramework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;net8.0&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">TargetFramework</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ImplicitUsings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;enable&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ImplicitUsings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;enable&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Nullable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">PropertyGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ItemGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 下面的版本不一定准确，只需是最新版即可 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">PackageReference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Microsoft.SemanticKernel.Abstractions&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.14.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ItemGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Project</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="创建插件类型" tabindex="-1">创建插件类型 <a class="header-anchor" href="#创建插件类型" aria-label="Permalink to &quot;创建插件类型&quot;">​</a></h2><p>哔哩助理的第一个命名约定：</p><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>插件类型应具备 <code>Plugin</code> 后缀。</p></div><p>假设我们要创建一个天气插件，那么我们现在需要在项目里新建一个类：<code>WeatherPlugin</code>:</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> System</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ComponentModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SemanticKernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyPlugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DisplayName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;天气插件&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;该插件可以获取天气相关的信息&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeatherPlugin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上面的类型定义中，我们需要用 <code>DisplayNameAttribute</code> 对应该插件的标题，<code>DescriptionAttribute</code> 对应该插件的描述，它们会显示在应用的插件列表中。</p><div style="max-width:320px;"><p><img src="`+e+`" alt="插件条目"></p></div><h2 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-label="Permalink to &quot;实现方法&quot;">​</a></h2><p>现在我们需要添加一个方法，该方法可以获取天气，我们在这里使用一个伪代码，你可以替换成具体的实现。</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KernelFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Get the weather of a city.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetWeatherAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Description</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;City name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> city</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    CancellationToken</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cancellationToken</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Task.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cancellationToken);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testText</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;The weather of &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> city </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; is sunny. 26℃.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> testText;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>首先，我们会创建一个名为 <code>GetWeatherAsync</code> 的异步方法，这是因为实际的代码通常涉及网络请求，而这是异步进行的。</p><p>然后，我们需要给这个方法添加两个特性。</p><table tabindex="0"><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>KernelFunctionAttribute</td><td>标识这是一个可以被调用的方法</td></tr><tr><td>DescriptionAttribute</td><td>提供对该方法的描述，尽量使用英文，这可以帮助模型判断是否要调用这个方法</td></tr></tbody></table><p><code>GetWeatherAsync</code> 有两个参数。</p><p>第一个是需要的参数，这里是城市名称，你可以用 <code>DescriptionAttribute</code> 来对其进行说明。</p><p>第二个是异步方法必须的参数，即 <code>CancellationToken</code>，在整个工具调用的过程中，如果用户点击了取消，那么这个终止令牌会从应用内扩散到这个方法，从而中止方法的执行。</p><p>在这个方法内，我们简单地返回了一个动态文本。</p><p>现在，我们就完成了插件的代码编写工作。</p><p>怎么样，是不是很简单？</p><h2 id="打包" tabindex="-1">打包 <a class="header-anchor" href="#打包" aria-label="Permalink to &quot;打包&quot;">​</a></h2><p>插件代码编写完成，接下来就是打包了。</p><p>右键单击项目，选择 <code>发布</code>，你可以按照如下配置进行插件打包发布（发布位置自行选择）：</p><p><img src="`+p+'" alt="类库发布"></p><p>配置创建完成后，点击发布页面右上角的 <code>发布</code> 按钮即可。</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>如果你准备面向 ARM64 发布，请选择 Release | ARM64，及对应的 win-arm64 运行时。</p></div><p>等待发布构建完成，然后打开发布文件夹，你能看到一堆 dll 文件。</p><p><img src="'+h+'" alt="插件发布文件夹"></p><p>接下来，全选，右键，压缩为 ZIP 文件即可。</p><p>最关键的，你需要修改压缩文件的名称为你的项目名称，即 <code>RodelAgent.Samples.Plugin.zip</code>。</p><p>这就是哔哩助理的第二个命名约定：</p><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p><strong>哔哩助理在导入插件时，会根据 ZIP 的名称查找压缩包内同名的 dll 文件，将之作为程序集导入，所以插件包的名称必须和你希望导入的 dll 的名称一致。</strong></p></div><h3 id="关于图标" tabindex="-1">关于图标 <a class="header-anchor" href="#关于图标" aria-label="Permalink to &quot;关于图标&quot;">​</a></h3><p>你可以为你的插件创建图标，这是哔哩助理的第三个命名约定：</p><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>你可以在压缩包内添加一个名为 <code>favicon.png</code> 的图片作为插件的图标。</p></div><h2 id="导入" tabindex="-1">导入 <a class="header-anchor" href="#导入" aria-label="Permalink to &quot;导入&quot;">​</a></h2><p>参考 <a href="./chat-tools#导入工具插件">工具调用</a> 在哔哩助理内导入 ZIP 压缩包即可。</p><h2 id="插件更新" tabindex="-1">插件更新 <a class="header-anchor" href="#插件更新" aria-label="Permalink to &quot;插件更新&quot;">​</a></h2><p>在哔哩助理内，插件是通过导入外部 DLL 的形式加载的，在应用运行期间内，不能直接使用新的 ZIP 替代旧的插件。</p><p>如果你需要更新插件，那么请关闭哔哩助理，然后在助理库文件夹内的 <code>Plugins</code> 子文件夹中删除对应的插件文件夹，之后打开应用，重新导入新的插件。</p><h2 id="q-a" tabindex="-1">Q&amp;A <a class="header-anchor" href="#q-a" aria-label="Permalink to &quot;Q&amp;A&quot;">​</a></h2><ol><li><p><strong>为什么要使用 <code>发布</code>，直接构建的 DLL 能不能用？</strong><br> 选择 <code>发布</code>，就是因为它可以包含该项目所有依赖的 DLL，哔哩助理在加载主 DLL 文件时，如果发现依赖缺失，那就会在插件目录中寻找依赖并加载。<br> 直接使用构建的 DLL 很容易出现依赖缺失的问题。</p></li><li><p><strong>为什么我导入了插件，但是插件列表一片空白？</strong><br> 显然，有什么地方出问题了。<br> 请打开设置页面，打开应用日志文件夹，找到当天的日志，打开查看日志记录，并针对性地进行排查。</p></li><li><p><strong>一个项目内可以有多个插件吗？</strong><br> 可以的，一个插件一个类型就没问题，导入后，每个插件类型都是一个插件条目，共享图标。</p></li></ol>',56)]))}const F=i(k,[["render",r]]);export{u as __pageData,F as default};
