// Copyright (c) Bili Copilot. All rights reserved.
// <auto-generated/>

using System.Diagnostics;
using Bili.Copilot.Libs.Player.Enums;
using FFmpeg.AutoGen;
using static Bili.Copilot.Libs.Player.Misc.Logger;

namespace Bili.Copilot.Libs.Player.MediaFramework.MediaDemuxer;

public unsafe class Interrupter
{
    private Demuxer _demuxer;
    private Stopwatch _sw = new();

    public int ForceInterrupt { get; set; }
    public Requester Requester { get; private set; }
    public int Interrupted { get; private set; }

    internal AVIOInterruptCB_callback InterruptClbk { get; set; }

    internal int ShouldInterrupt(void* opaque)
    {
        if (_demuxer.Status == ThreadStatus.Stopping)
        {
            if (CanDebug)
                _demuxer.Log.Debug($"{_demuxer.Interrupter.Requester} Interrupt (Stopping) !!!");

            return _demuxer.Interrupter.Interrupted = 1;
        }

        if (_demuxer.Config.AllowTimeouts)
        {
            long curTimeout = 0;
            switch (_demuxer.Interrupter.Requester)
            {
                case Requester.Close:
                    curTimeout = _demuxer.Config.CloseTimeout;
                    break;

                case Requester.Open:
                    curTimeout = _demuxer.Config.OpenTimeout;
                    break;

                case Requester.Read:
                    curTimeout = _demuxer.Config.ReadTimeout;
                    break;

                case Requester.Seek:
                    curTimeout = _demuxer.Config.SeekTimeout;
                    break;
            }

            if (_sw.ElapsedMilliseconds > curTimeout / 10000)
            {
                _demuxer.OnTimedOut();

                // Prevent Live Streams from Timeout (while demuxer is at the end)
                if (_demuxer.Interrupter.Requester == Requester.Read && (_demuxer.Duration == 0 || (_demuxer.HlsPlaylist != null && _demuxer.HlsPlaylist->cur_seq_no > _demuxer.HlsPlaylist->last_seq_no - 2)))
                {
                    // TBR: Add retries (per input? per thread start?) as it can actually ended and keep reading forever
                    if (CanTrace)
                        _demuxer.Log.Trace($"{_demuxer.Interrupter.Requester} Timeout !!!! {_sw.ElapsedMilliseconds} ms | Live HLS Excluded");

                    _demuxer.Interrupter.Request(Requester.Read);

                    return _demuxer.Interrupter.Interrupted = 0;
                }

                if (CanWarn)
                    _demuxer.Log.Warn($"{_demuxer.Interrupter.Requester} Timeout !!!! {_sw.ElapsedMilliseconds} ms");

                return _demuxer.Interrupter.Interrupted = 1;
            }
        }

        if (_demuxer.Interrupter.Requester == Requester.Close)
            return 0;

        if (_demuxer.Interrupter.ForceInterrupt != 0 && _demuxer.allowReadInterrupts)
        {
            if (CanTrace)
                _demuxer.Log.Trace($"{_demuxer.Interrupter.Requester} Interrupt !!!");
            return _demuxer.Interrupter.Interrupted = 1;
        }

        return _demuxer.Interrupter.Interrupted = 0;
    }

    public Interrupter(Demuxer demuxer)
    {
        this._demuxer = demuxer;
        InterruptClbk = ShouldInterrupt;
    }

    public void Request(Requester requester)
    {
        if (!_demuxer.Config.AllowTimeouts)
            return;

        Requester = requester;
        _sw.Restart();
    }
}
