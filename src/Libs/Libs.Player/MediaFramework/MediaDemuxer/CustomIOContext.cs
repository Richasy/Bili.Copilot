// Copyright (c) Bili Copilot. All rights reserved.
// <auto-generated/>

using System;
using System.IO;

using FFmpeg.AutoGen;
using static FFmpeg.AutoGen.ffmpeg;

namespace Bili.Copilot.Libs.Player.MediaFramework.MediaDemuxer;

public unsafe class CustomIOContext
{
    AVIOContext* avioCtx;
    public Stream stream;
    Demuxer demuxer;

    public CustomIOContext(Demuxer demuxer)
    {
        this.demuxer = demuxer;
    }

    public void Initialize(Stream stream)
    {
        this.stream = stream;
        ioread = IORead;
        ioseek = IOSeek;
        avioCtx = avio_alloc_context((byte*)av_malloc((ulong)demuxer.Config.IOStreamBufferSize), demuxer.Config.IOStreamBufferSize, 0, null, ioread, null, ioseek);
        demuxer.FormatContext->pb = avioCtx;
        demuxer.FormatContext->flags |= AVFMT_FLAG_CUSTOM_IO;
    }

    public void Dispose()
    {
        if (avioCtx != null)
        {
            av_free(avioCtx->buffer);
            fixed (AVIOContext** ptr = &avioCtx)
                avio_context_free(ptr);
        }
        avioCtx = null;
        stream = null;
        ioread = null;
        ioseek = null;
    }

    avio_alloc_context_read_packet ioread;
    avio_alloc_context_seek ioseek;

    int IORead(void* opaque, byte* buffer, int bufferSize)
    {
        int ret;

        if (demuxer.Interrupter.ShouldInterrupt(null) != 0)
            return AVERROR_EXIT;
        ret = demuxer.CustomIOContext.stream.Read(new Span<byte>(buffer, bufferSize));
        if (ret < 0)
        { demuxer.Log.Warn("CustomIOContext Interrupted"); return AVERROR_EXIT; }
        return ret;
    }

    long IOSeek(void* opaque, long offset, int whence)
    {
        return whence == AVSEEK_SIZE
            ? demuxer.CustomIOContext.stream.Length
            : demuxer.CustomIOContext.stream.Seek(offset, (SeekOrigin)whence);
    }
}
