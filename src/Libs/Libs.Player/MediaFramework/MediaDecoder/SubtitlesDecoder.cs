// Copyright (c) Bili Copilot. All rights reserved.
// <auto-generated />

using System;
using System.Collections.Concurrent;
using System.Threading;
using Bili.Copilot.Libs.Player.Core;
using Bili.Copilot.Libs.Player.Enums;
using Bili.Copilot.Libs.Player.MediaFramework.MediaFrame;
using Bili.Copilot.Libs.Player.MediaFramework.MediaStream;
using FFmpeg.AutoGen;
using static FFmpeg.AutoGen.ffmpeg;
using static Bili.Copilot.Libs.Player.Misc.Logger;
using Bili.Copilot.Libs.Player.Core.Engines;

namespace Bili.Copilot.Libs.Player.MediaFramework.MediaDecoder;

public unsafe class SubtitlesDecoder : DecoderBase
{
    public SubtitlesStream SubtitlesStream => (SubtitlesStream)Stream;

    public ConcurrentQueue<SubtitleFrame> Frames { get; protected set; } = new ConcurrentQueue<SubtitleFrame>();

    public SubtitlesDecoder(Config config, int uniqueId = -1)
        : base(config, uniqueId)
    {
    }

    protected override unsafe int Setup(AVCodec* codec) => 0;

    protected override void DisposeInternal()
        => Frames = new ConcurrentQueue<SubtitleFrame>();

    public void Flush()
    {
        lock (LockActions)
            lock (_lockCodecCtx)
            {
                if (Disposed)
                    return;

                if (Status == ThreadStatus.Ended)
                    Status = ThreadStatus.Stopped;

                DisposeFrames();
                avcodec_flush_buffers(codecCtx);
            }
    }

    protected override void RunInternal()
    {
        int ret = 0;
        int allowedErrors = Config.Decoder.MaxErrors;
        AVPacket* packet;

        do
        {
            // Wait until Queue not Full or Stopped
            if (Frames.Count >= Config.Decoder.MaxSubsFrames)
            {
                lock (LockStatus)
                    if (Status == ThreadStatus.Running)
                        Status = ThreadStatus.QueueFull;

                while (Frames.Count >= Config.Decoder.MaxSubsFrames && Status == ThreadStatus.QueueFull)
                    Thread.Sleep(20);

                lock (LockStatus)
                {
                    if (Status != ThreadStatus.QueueFull)
                        break;
                    Status = ThreadStatus.Running;
                }
            }

            // While Packets Queue Empty (Ended | Quit if Demuxer stopped | Wait until we get packets)
            if (demuxer.SubtitlesPackets.Count == 0)
            {
                CriticalArea = true;

                lock (LockStatus)
                    if (Status == ThreadStatus.Running)
                        Status = ThreadStatus.QueueEmpty;

                while (demuxer.SubtitlesPackets.Count == 0 && Status == ThreadStatus.QueueEmpty)
                {
                    if (demuxer.Status == ThreadStatus.Ended)
                    {
                        Status = ThreadStatus.Ended;
                        break;
                    }
                    else if (!demuxer.IsRunning)
                    {
                        if (CanDebug)
                            Log.Debug($"Demuxer is not running [Demuxer Status: {demuxer.Status}]");

                        int retries = 5;

                        while (retries > 0)
                        {
                            retries--;
                            Thread.Sleep(10);
                            if (demuxer.IsRunning)
                                break;
                        }

                        lock (demuxer.LockStatus)
                            lock (LockStatus)
                            {
                                if (demuxer.Status == ThreadStatus.Pausing || demuxer.Status == ThreadStatus.Paused)
                                    Status = ThreadStatus.Pausing;
                                else if (demuxer.Status != ThreadStatus.Ended)
                                    Status = ThreadStatus.Stopping;
                                else
                                    continue;
                            }

                        break;
                    }

                    Thread.Sleep(20);
                }

                lock (LockStatus)
                {
                    CriticalArea = false;
                    if (Status != ThreadStatus.QueueEmpty)
                        break;
                    Status = ThreadStatus.Running;
                }
            }

            lock (_lockCodecCtx)
            {
                if (Status == ThreadStatus.Stopped || demuxer.SubtitlesPackets.Count == 0)
                    continue;
                packet = demuxer.SubtitlesPackets.Dequeue();
                int gotFrame = 0;
                AVSubtitle sub = new();
                ret = avcodec_decode_subtitle2(codecCtx, &sub, &gotFrame, packet);
                if (ret < 0)
                {
                    allowedErrors--;
                    if (CanWarn)
                        Log.Warn($"{FFmpegEngine.ErrorCodeToMsg(ret)} ({ret})");

                    if (allowedErrors == 0)
                    { Log.Error("Too many errors!"); Status = ThreadStatus.Stopping; break; }

                    continue;
                }

                if (gotFrame < 1 || sub.num_rects < 1)
                    continue;
                if (packet->pts == AV_NOPTS_VALUE)
                { avsubtitle_free(&sub); av_packet_free(&packet); continue; }

                // TODO: CodecChanged? And when findstreaminfo is disabled as it is an external demuxer will not know the main demuxer's start time
                if (!filledFromCodec)
                {
                    filledFromCodec = true;
                    avcodec_parameters_from_context(Stream.AVStream->codecpar, codecCtx);
                    SubtitlesStream.Refresh();

                    CodecChanged?.Invoke(this);
                }

                var mFrame = ProcessSubtitlesFrame(packet, &sub);
                if (mFrame != null)
                    Frames.Enqueue(mFrame);

                avsubtitle_free(&sub);
                av_packet_free(&packet);
            }
        } while (Status == ThreadStatus.Running);
    }

    private SubtitleFrame ProcessSubtitlesFrame(AVPacket* packet, AVSubtitle* sub)
    {

        try
        {
            string line = string.Empty;
            byte[] buffer;
            var rects = sub->rects;
            var cur = rects[0];

            switch (cur->type)
            {
                case AVSubtitleType.SUBTITLE_ASS:
                case AVSubtitleType.SUBTITLE_TEXT:
                    buffer = new byte[1024];
                    line = Utils.BytePtrToStringUtf8(cur->ass);
                    break;

                //case AVSubtitleType.SUBTITLE_BITMAP:
                //Log("Subtitles BITMAP -> Not Implemented yet");

                default:
                    return null;
            }

            SubtitleFrame mFrame = new(line)
            {
                Duration = (int)(sub->end_display_time - sub->start_display_time),
                Timestamp = (long)(packet->pts * SubtitlesStream.TimeBase) - demuxer.StartTime + Config.Subtitles.Delay
            };

            if (CanTrace)
                Log.Trace($"Processes {Utils.TicksToTime(mFrame.Timestamp)}");

            Config.Subtitles.Parser(mFrame);

            return mFrame;
        }
        catch (Exception e) { Log.Error($"Failed to process frame ({e.Message})"); return null; }
    }

    public void DisposeFrames()
        => Frames = new ConcurrentQueue<SubtitleFrame>();
}
